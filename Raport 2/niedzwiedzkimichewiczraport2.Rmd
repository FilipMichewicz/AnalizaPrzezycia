---
title: "Analiza Przeżycia"
author: "Wiktor Niedźwiedzki (258882)  \n  Filip Michewicz (282239)"
date: "8 grudnia 2025 Anno Domini"
output:
  pdf_document:
    number_sections: true
  word_document: default
subtitle: Raport 2
toc: true
lof: true
lot: true
header-includes:
- \usepackage[OT4]{polski}
- \usepackage[utf8]{inputenc}
- \usepackage{graphicx}
- \usepackage{float}
- \usepackage{hyperref}
- \renewcommand{\contentsname}{Spis treści}
- \renewcommand{\listfigurename}{Spis wykresów}
- \renewcommand{\listtablename}{Spis tabel}
- \renewcommand{\figurename}{Wykres}
- \renewcommand{\tablename}{Tabela}
- \usepackage{xcolor}
- \definecolor{ForestGreen}{rgb}{0.1333, 0.5451, 0.1333}
- \definecolor{SteelBlue}{rgb}{0.2745, 0.5098, 0.7059}
- \definecolor{Tomato}{rgb}{1.0, 0.3882, 0.2784}
- \usepackage{etoolbox}
- \pretocmd{\tableofcontents}{\clearpage}{}{}
- \patchcmd{\thebibliography}{\section*{\refname}}{}{}{}
---

```{r biblioteki+zmienne_pomocnicze, include=FALSE}
library(knitr)
library(ggplot2)
library(survival)
library(survminer)
library(coin)
library(xtable)
library(gridExtra)
library(latex2exp)

knitr::opts_chunk$set(fig.align='center', 
                      fig.pos='H', 
                      #dev='png', 
                      dpi=1200, 
                      fig.width = 6, 
                      fig.height = 3.5,
                      cache=TRUE)

# ZMNIEJSZENIE FONTÓW GLOBALNIE
theme_set(
  theme_minimal() +
    theme(
      axis.text  = element_text(size = 7),
      axis.title = element_text(size = 8),
      legend.text  = element_text(size = 7),
      legend.title = element_text(size = 8)
    )
)

set.seed(21370)
```

```{r szajs_z_poprzedniego_raportu, echo=FALSE}
# Nieśmiertelne dane z lista 2 zadanie 3
times.A <- c(0.03345514, 0.08656403, 0.08799947, 0.24385821, 0.27755032,
            0.40787247, 0.58825664, 0.64125620, 0.90679161, 0.94222208, 
            rep(1, 10))
deltas.A <- c(rep(1,10), rep(0,10))

df.A <- data.frame(times = times.A, deltas = deltas.A)

times.B <- c(0.03788958, 0.12207257, 0.20319983, 0.24474299, 0.30492413,
            0.34224462, 0.42950144, 0.44484582, 0.63805066, 0.69119721, 
            rep(1, 10))
deltas.B <- c(rep(1,10), rep(0,10))

df.B <- data.frame(times = times.B, deltas = deltas.B)

# Kwantyle, generator z EW, cenzurwator i cenzurator z GE
EW_quantile <- function(p, alpha, beta, gamm) {
  beta * (-log(1 - p^(1 / gamm)))^(1 / alpha)
}

EW_generator <- function(alpha, beta, gamm, size = 1) {
  u <- runif(size)
  EW_quantile(u, alpha, beta, gamm)
}

cenzurowanie_I_typu <- function(t0, data) {
  censored_data <- ifelse(data <= t0, data, t0)
  deltas <- ifelse(data <= t0, 1, 0)
  list(times = censored_data, deltas = deltas)
}

GE_cenzurowanie_I_typu <- function(t0, alpha, lambd, n) {
  data <- EW_generator(alpha = 1, beta = 1/lambd, gamm = alpha, size = n)
  cenzurowanie_I_typu(t0, data)
}
```

\newpage
# Lista 5

Lista obejmuje estymatory funkcji przeżycia dla danych niecenzurowanych, w szczególności estymator Kaplana–Meiera oraz estymator Fleminga–Harringtona, zarówno bez korekty, jak i z ogonem estymowanym według propozycji Browna, Hollandera i Kowara. Dodatkowo przeprowadzono oszacowanie wartości funkcji przeżycia w chwili cenzurowania oraz w dwukrotności czasu cenzurowania, na podstawie symulacji dla danych generowanych z uogólnionego rozkładu wykładniczego $\mathcal{GE}(\lambda, \alpha)$.
 
## Zadanie 1

W tym zadaniu wygenerowano wykres estymatorów Kaplana–Meiera oraz Fleminga–Harringtona funkcji przeżycia dla danych z zadania 3 z listy 2, których opis przedstawiono w poprzednim raporcie.

### Estymator Kaplana-Meiera

Estymator Kaplana–Meiera jest nieparametrycznym estymatorem funkcji przeżycia, opartym na iloczynie warunkowych prawdopodobieństw przeżycia kolejnych chwil zdarzeń. Definiuje się go jako

$$
\hat{S}(t) = \prod_{i:\, t_{(i)} \le t} \left( 1 - \frac{d_i}{r_i} \right),
$$

gdzie

$$
r_i = \sum_{j=1}^n \mathbf{1}_{[\,t_{(i)},\infty\,)}(t_j), \qquad 
d_i = \sum_{j=1}^n \mathbf{1}_{\{t_{(i)}\}}(t_j)\,\mathbf{1}_{\{1\}}(\delta_j).
$$

Wielkość $r_i$ to liczba obserwacji, które w chwili $t_{(i)}$ pozostają w stanie ryzyka, czyli dotrwały do czasu $t_{(i)}$ bez wcześniejszego zdarzenia ani cenzurowania i mogą jeszcze doświadczyć zdarzenia w tym momencie, natomiast $d_i$ to liczba zdarzeń (niezależnych od cenzurowania) zachodzących dokładnie w czasie $t_{(i)}$.

Estymator Kaplana–Meiera nie został zdefiniowany ręcznie w tym raporcie, lecz jego implementacja znajduje się w bibliotece `survival` w pakiecie R. Funkcja `survfit` domyślnie dopasowuje dane w formacie `Surv`, czyli takim, w którym określone są czasy obserwacji oraz wskaźniki cenzurowania, i domyślnie używa estymatora Kaplana–Meiera.

Poniżej przedstawiono blok kodu w R, który realizuje estymację funkcji przeżycia za pomocą tego estymatora:

```{r Kaplan-Meier-estimator}
surv.A <- Surv(df.A$times, df.A$deltas)
surv.B <- Surv(df.B$times, df.B$deltas)

# Estymator Kaplana-Meiera
fit.KM.A <- survfit(surv.A ~ 1)
fit.KM.B <- survfit(surv.B ~ 1)

# Ramki danych do wykresu
plot.A <- data.frame(time = c(0, fit.KM.A$time), 
                     surv = c(1, fit.KM.A$surv), 
                     group = "A")

plot.B <- data.frame(time = c(0, fit.KM.B$time), 
                     surv = c(1, fit.KM.B$surv), 
                     group = "B")

plot.df  <- rbind(plot.A, plot.B)
```

Poniżej przedstawiono wykres estymowanej funkcji przeżycia uzyskanej przy użyciu estymatora Kaplana–Meiera dla danych z zadania 3 z listy 2.

```{r KM-plot, echo=FALSE, fig.cap="Estymator Kaplana-Meiera dla danych dotyczących leków"}
ggplot(plot.df, aes(x = time, y = surv, color = group)) +
  geom_step(linewidth = 1.2) +
  scale_color_manual(values = c("A" = "steelblue", "B" = "tomato"),
                     labels = c("Lek A", "Lek B")) +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Czas do remisji (t)",
       y = expression(hat(S)(t)),
       color = "Grupa") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

\hyperref[fig:KM-plot]{Wykres \ref*{fig:KM-plot}.} przedstawia estymowaną funkcję przeżycia za pomocą estymatora Kaplana–Meiera. Dane w obu przypadkach są prawostronnie cenzurowane typu I, zatem największe wartości w zbiorach danych są cenzurowane, a po ostatnim pełnym (niecenzurowanym) czasie występują obserwacje cenzurowane, przez co estymator nie jest określony dla $t > t_{(n)}$. Dlatego do czasu $t \leq t_{(n)}$ estymator Kaplana–Meiera jest dobrze określony. W przypadku gdyby obserwacja $t_{(n)}$ była kompletna, to dla $t > t_{(n)}$  mielibyśmy $\hat{S}(t)=0$.

### Estymator Fleminga-Harringtona

Estymator Fleminga–Harringtona jest estymatorem funkcji przeżycia, opartym na zależności między funkcją przeżycia a funkcją skumulowanego hazardu; wykorzystuje estymator funkcji hazardu, a w konsekwencji skumulowanej funkcji hazardu zaproponowany przez Nelsona–Aalena. Szczegóły dotyczące konstrukcji estymatora i jego relacji do funkcji skumulowanego hazardu przedstawiono na wykładzie. Funkcję przeżycia estymuje się według wzoru:

$$
\tilde{S}(t) = \exp\left(-\sum_{j:\, t_{(j)} \le t} \frac{d_j}{r_j}\right), \quad 0 \le t \le t_{(n)}
$$

gdzie $d_j$ to liczba zdarzeń w chwili $t_{(j)}$, a $r_j$ - liczba obserwacji pozostających w stanie ryzyka w czasie $t_{(j)}$.

Podobnie jak w poprzednim podpunkcie, estymator Fleminga–Harringtona nie został zdefiniowany ręcznie w tym raporcie, lecz jego implementacja znajduje się w bibliotece `survival` w pakiecie R. Tym razem w funkcji `survfit` zastosowano opcję `type = "fleming-harrington"`.

Poniżej przedstawiono blok kodu w R, który realizuje estymację funkcji przeżycia za pomocą tego estymatora:

```{r FH-estimator}
# Estymator Fleminga-Harringtona
fit.FH.A <- survfit(surv.A ~ 1, type = "fleming-harrington")
fit.FH.B <- survfit(surv.B ~ 1, type = "fleming-harrington")

# Ramki danych do wykresu
plot.A <- data.frame(time = c(0, fit.FH.A$time), 
                     surv = c(1, fit.FH.A$surv), 
                     group = "A")

plot.B <- data.frame(time = c(0, fit.FH.B$time), 
                     surv = c(1, fit.FH.B$surv), 
                     group = "B")

plot.df  <- rbind(plot.A, plot.B)
```

Poniżej przedstawiono wykres estymowanej funkcji przeżycia uzyskanej przy użyciu estymatora Fleminga-Harringtona.

```{r FH-plot, echo=FALSE, fig.cap="Estymator Fleminga-Harringtona dla danych dotyczących leków"}
ggplot(plot.df, aes(x = time, y = surv, color = group)) +
  geom_step(linewidth = 1.2) +
  scale_color_manual(values = c("A" = "steelblue", "B" = "tomato"),
                     labels = c("Lek A", "Lek B")) +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Czas do remisji (t)",
       y = expression(hat(S)(t)),
       color = "Grupa") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

\hyperref[fig:FH-plot]{Wykres \ref*{fig:FH-plot}.} przedstawia estymowaną funkcję przeżycia za pomocą estymatora Fleminga-Harringtona. Uwagi dotyczące bycia dobrze określonym są analogiczne jak do estymatora Kaplana-Meiera.

Obydwa estymatory dają podobne wyniki. W krótkim czasie lek B wydaje się korzystniejszy (wyższa funkcja przeżycia, dłuższy czas do remisji), natomiast dla $t > 0,5$ bardziej efektywny staje się lek A. Do dokładniejszej analizy warto zastosować, np. test Kołmogorowa–Smirnowa.

## Zadanie 2

Zadanie dotyczy generowania wykresu funkcji przeżycia estymowanej metodą Kaplana–Meiera, z uwzględnieniem oszacowania ogona funkcji przeżycia, zaproponowanego przez Browna, Hollandera i Kowara.

Brown, Hollander i Kowar (1974) sugerowali oszacowanie ogona funkcji przeżycia przez odpowiednio dobraną funkcję przeżycia rozkładu wykładniczego, taką, aby w punkcie $t^+$ (ostatnim zarejestrowanym czasie) była równa $S(t^+)$.

Po krótkich obliczeniach przeprowadzonych na wykładzie otrzymuje się:

$$
\hat{S}(t) = \exp\left(\frac{\ln \hat{S}(t^+)}{t^+} t\right), \quad t > t^+.
$$
Dla $t \leq t^+$ stosuje się klasyczny estymator Kaplana–Meiera.

Poniżej przedstawiono blok kodu w R, który umożliwia estymację funkcji przeżycia wraz z uwzględnieniem ogona.

```{r ogon-plot}
BHK.tail <- function(df, end = 3, type = "kaplan-meier") {
  # Estymator KM
  fit <- survfit(Surv(df$times, df$deltas) ~ 1, type = type)
  df.complete <- data.frame(time = fit$time, 
                            surv = fit$surv)

  # Ogin
  t_plus <- tail(df.complete$time, 1)
  S_plus <- tail(df.complete$surv, 1)
  
  theta <- -log(S_plus) / t_plus
  
  # Generowanie ogona
  time_tail <- seq(t_plus, end, length.out = 1000)
  surv_tail <- exp(-theta * time_tail)
  df_tail <- data.frame(time = time_tail, surv = surv_tail)
  
  df.complete <- rbind(df.complete, df_tail)
  
  # Dodanie punktu początkowego
  df.complete <- rbind(data.frame(time = 0, surv = 1), df.complete)
  return(df.complete)
}
```

Poniżej przedstawiono wykres estymowanej funkcji przeżycia uzyskanej przy użyciu estymatora Kaplana–Meiera wraz z ogonem dla danych z zadania 3 z listy 2.

```{r KM-ogon-plot, echo=FALSE, fig.cap="Estymator Kaplana-Meiera wraz z ogonem Browna, Hollandera i Kowara dla danych dotyczących leków"}
plot.A <- BHK.tail(df.A)
plot.A$group <- "A"
plot.B <- BHK.tail(df.B)
plot.B$group <- "B"
plot.df <- rbind(plot.A, plot.B)

ggplot(plot.df, aes(x = time, y = surv, color = group)) +
  geom_step(linewidth = 1.2) +
  scale_color_manual(values = c("A" = "steelblue", "B" = "tomato"),
                     labels = c("Lek A", "Lek B")) +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Czas do remisji (t)",
       y = "Estymowana wartość funkcji przeżycia S(t)",
       color = "Grupa") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

\hyperref[fig:KM-ogon-plot]{Wykres \ref*{fig:KM-ogon-plot}.} przedstawia estymator Kaplana–Meiera wraz z ogonem zaproponowanym przez Browna, Hollandera i Kowara dla danych dotyczących leków. Do czasu ostatniej obserwacji kompletnej wykorzystano klasyczny estymator Kaplana–Meiera, natomiast dla czasów przekraczających tę obserwację wartość funkcji przeżycia (tzw. ogon) estymowana jest przy użyciu odpowiednio dobranej funkcji wykładniczej. Warto zauważyć, że estymowana funkcja jest ciągła w punkcie $t^+$. Ze względu na to, że $t^+_A=t^+_B=t_0=1$, ogony w obu grupach pokrywają się.

## Zadanie 3

Zadanie polega na wygenerowaniu $M = 1000$ zbiorów danych cenzurowanych I-go typu z uogólnionego rozkładu wykładniczego $\mathcal{GE}(\lambda, \alpha)$ dla $\alpha = 2$ i $\lambda = 2$, przy licznościach próby $n = 30, 50, 100$. Wartość $t_0$ przyjęto równą wartości oczekiwanej rozkładu $\mathcal{GE}(\lambda, \alpha)$ \cite{gupta1999}:

$$
t_0 = \lambda \left( \psi(\alpha + 1) - \psi(1) \right)
$$

gdzie $\psi(\cdot)$ jest funkcją digamma, tj. logarytmiczną pochodną funkcji gamma.


Na podstawie wygenerowanych zbiorów danych oszacowano wartość funkcji przeżycia w punktach $t_0$ i $2 t_0$, korzystając z estymatora Kaplana–Meiera z uwzględnieniem ogona estymowanego zgodnie z propozycją Browna, Hollandera i Kowara. Ostatecznie wygenerowano histogramy oszacowań w tych punktach dla każdego $n$ i oceniono, czy istnieją podstawy do przypuszczenia, że estymator Kaplana–Meiera jest asymptotycznie normalny.

Konstrukcja estymatora Kaplana–Meiera wraz z "ogonem" została omówiona w dwóch poprzednich zadaniach i nie będzie tutaj ponownie przytaczana.

Poniżej przedstawiono blok kodu w pakiecie R wyznaczający, za pomocą estymatora Kaplana–Meiera z "ogonem", estymowaną wartość funkcji przeżycia w punkcie $t$.

```{r surv-value}
KM.surv.value <- function(df, type = "kaplan-meier", t) {
  # Estymator KM
  fit <- survfit(Surv(df$times, df$deltas) ~ 1, type = type)
  event_idx <- which(fit$n.event > 0)
  df.complete <- data.frame(time = fit$time[event_idx], 
                            surv = fit$surv[event_idx])
  
  df.complete <- data.frame(time = fit$time, surv = fit$surv)
  
  t_plus <- tail(df.complete$time, 1)
  
  if (t <= t_plus) {
    value <- df.complete$surv[max(which(df.complete$time <= t))]
  } else {
    S_plus <- tail(df.complete$surv, 1)
    
    theta <- -log(S_plus) / t_plus
    
    value <- exp(-theta * t)
  }
  return(value)
}
```

Poniżej przedstawiono blok kodu w pakiecie R przeprowadzający opisaną na początku zadania symulację. W trakcie obliczeń zapisywane są estymowane wartości funkcji przeżycia w punktach $t_0$ oraz $2 t_0$. Na podstawie wyników sporządzono stosowne histogramy.

```{r symulation}
M <- 1000
n_values <- c(30, 50, 100)
alpha <- 2
lambda <- 2

t0 <- (digamma(alpha + 1) - digamma(1)) / lambda

results_t0 <- list()
results_2t0 <- list()

for (n in n_values) {
  surv_t0 <- numeric(M)
  surv_2t0 <- numeric(M)
  
  m <- 0
  while (m < M) {
    # generowanie danych cenzurowanych I typu
    cenzurowane <- GE_cenzurowanie_I_typu(t0, alpha, lambda, n)
    if (sum(cenzurowane$deltas) == 0) {
      next
      }
    m <- m + 1
    
    # estymator KM z "ogonem" w t0
    surv_t0[m] <- KM.surv.value(cenzurowane, t = t0)
    
    # estymator KM z "ogonem" w 2*t0
    surv_2t0[m] <- KM.surv.value(cenzurowane, t = 2*t0)
  }
  
  results_t0[[as.character(n)]] <- surv_t0
  results_2t0[[as.character(n)]] <- surv_2t0
}
```

```{r histogramy, echo=FALSE}
histograms <- list()

for (n in n_values) {
  df <- data.frame(
    Surv = c(results_t0[[as.character(n)]], results_2t0[[as.character(n)]]),
    Time = c(rep("t0", M), rep("2t0", M))
  )
  
  # Reguła Scotta
  sd <- max(sd(df$Surv[1:M]), sd(df$Surv[(M+1):(2*M)]))
  h <- 3.5*sd*M^(-1/3)
  
  p <- ggplot(df, aes(x = Surv, fill = Time)) +
    geom_histogram(position = "identity", binwidth = h, alpha = 0.6, color = "black") +
    scale_fill_manual(values = c("t0" = "tomato", "2t0" = "steelblue"),
                      labels = c("t0" = expression(t[0]), 
                                 "2t0" = expression(2 * t[0]))) +
    labs(x = "Estymacja funkcji przeżycia", 
         y = "Liczba symulacji", 
         fill = "Punkt czasu") +
    theme_minimal() +
    theme(legend.position = "bottom")
  
  histograms[[as.character(n)]] <- p
}
```

```{r hist-1, echo=FALSE, fig.cap="Histogram oszacowań funkcji przeżycia w punktach $t_0$ oraz $2 t_0$ - liczność próby n = 30"}
histograms$"30"
```

\hyperref[fig:hist-1]{Wykres \ref*{fig:hist-1}.} przedstawia estymowaną wartość funkcji przeżycia w punktach $t_0$ oraz $2 t_0$ dla próby o liczności $n = 30$. Estymowane wartości dla $2 t_0$ są mniejsze niż dla $t_0$ co zgadza się z oczekiwaniami.


```{r hist-2, echo=FALSE, fig.cap="Histogram oszacowań funkcji przeżycia w punktach $t_0$ oraz $2 t_0$ - liczność próby n = 50"}
histograms$"50"
```

\hyperref[fig:hist-2]{Wykres \ref*{fig:hist-2}.} przedstawia estymowaną wartość funkcji przeżycia w punktach $t_0$ oraz $2 t_0$ dla próby o liczności $n = 50$. W porównaniu z próbą o liczności $n = 30$ przedstawionej na \hyperref[fig:hist-1]{Wykresie \ref*{fig:hist-1}.} estymowane wartości przesunęły się ku mniejszym wartością.

```{r hist-3, echo=FALSE, fig.cap="Histogram oszacowań funkcji przeżycia w punktach $t_0$ oraz $2 t_0$ - liczność próby n = 100"}
histograms$"100"
```

\hyperref[fig:hist-3]{Wykres \ref*{fig:hist-3}.} przedstawia estymowaną wartość funkcji przeżycia w punktach $t_0$ oraz $2 t_0$ dla próby o liczności $n = 30$. Podobnie jak na poprzednim \hyperref[fig:hist-2]{Wykresie} wraz ze wzrostem próby wartości przesunęły się ku mniejszym wartością. 

Wraz ze wzrostem liczności próby, histogramy z poprzednich wykresów układają się w kształt dzwonowy charakterystyczny dla rozkładu normalnego. To z kolei pozwala przypuszczać, że estymator Kaplana–Meiera jest asymptotycznie normalny w punktach $t_0$ oraz $2 t_0$. Do dalszej analizy wykorzystano test Shapiro-Wilka, który w pakiecie R dostępny jest w funckji `shapiro.test` z pakietu `stats`.

```{r shapiro-wilk, echo=FALSE}
df <- data.frame(t0 = c(shapiro.test(results_t0$"30")$p.value,
                        shapiro.test(results_t0$"50")$p.value,
                        shapiro.test(results_t0$"100")$p.value),
                 t02 = c(shapiro.test(results_2t0$"30")$p.value,
                         shapiro.test(results_2t0$"50")$p.value,
                         shapiro.test(results_2t0$"100")$p.value))

rownames(df) <- c("30", "50", "100")

kable(df, digits=9, escape=FALSE, col.names = c("n", "$t_0$", "$2t_0$"), caption="\\label{tab:testy-sw} Wartości $p$ testu Shapiro-Wilka dla oszacowań funkcji przeżycia w punktach $t_0$ oraz $2 t_0$")
```

Z \hyperref[tab:testy-sw]{Tabeli \ref*{tab:testy-sw}.} można odczytać że dla wszystkich przypadku $p$-value jest równe zeru lub bliskie zera, a zatem dla prawie każdego poziomu $\alpha$ powinniśmy odrzucić hipotezę o normalności rozkładów, zarówno dla punktu $t_0$, jak i $2t_0$.

\newpage
# Lista 6

Lista dotyczy estymacji średniego czasu życia w oparciu o estymatory Kaplana–Meiera oraz Fleminga–Harringtona, z uwzględnieniem szacowania "ogona" zaproponowanego przez Browna, Hollandera i Kowara. Dodatkowo dokonano estymacji średniego czasu życia dla danych pochodzących z zadania 3 z listy 2.

## Zadanie 1

Zadanie polega na zdefiniowaniu funkcji obliczającej średni czas życia w oparciu o estymatory Kaplana–Meiera oraz Fleminga–Harringtona, z uwzględnieniem ogona wykładniczego według propozycji Browna, Hollandera i Kowara. Ze względu na podobieństwo wyglądu wynikowego estymatora dla obu metod, obliczenia zostaną przeprowadzone w uogólnionym przypadku.

Wartość oczekiwaną zmiennej losowej $X$, absolutnie ciągłej względem miary Lebesgue’a, można oszacować na dwa sposoby:

1. Obliczając
   $$
   \mathbb{E}[X] = \int_{\mathbb{R}} xf(x) dx,
   $$
   gdzie $f(x)$ jest funkcją gęstości rozkładu zmiennej losowej (X).

2. Jeżeli rozkład $X$ ma nośnik $(0, \infty)$, to obliczając:
   $$
   \mathbb{E}[X] = \int_0^{\infty} S(x)dx,
   $$
   czyli poprzez całkowanie ogona funkcji przeżycia $S(x)$.

Jako że zarówno estymator Kaplana–Meiera, jak i Fleminga–Harringtona są estymatorami funkcji przeżycia, wartość oczekiwaną zmiennej losowej można oszacować za pomocą wzoru:

$$
\hat{\mu} = \int_0^{\infty} \hat{S}(x)dx,
$$

gdzie $\hat{S}(x)$ oznacza estymowaną funkcję przeżycia.

Ze względu na to że $\hat{S}(x)$ na przedziale $(0, t^+)$ jest funkcją schodkową, dlatego $\hat{\mu}$ będzie obliczana według wzoru:

$$
\hat{\mu} \phantom{cc} = \sum_{i:, t_{(i)} \le t^+} \hat{S}\left(t_{(i)}\right)\left(t_{(i)} - t_{(i-1)}\right), \quad t_{(0)} := 0,
$$

gdzie $\hat{S}(t_{(i)})$ to wartość estymatora funkcji przeżycia w chwili $t_{(i)}$, a sumowanie jest wykonywane tylko do czasu ostatniej obserwacji $t^+$. Powyżej $t^+$ obydwa estymatory są nieokreślone.

Jeżeli natomiast estymator będzie zawierał "ogon" według propozycji Browna, Hollandera i Kowara należy powiększyć wartość $\mu$ o wartość oczekiwaną na tym właśnie "ogonie".

$$
\begin{aligned}
\int_{t^+}^{\infty} e^{-\theta t} \, dt &= \lim_{b \to \infty} \int_{t^+}^{b} e^{-\theta t} \, dt = \lim_{b \to \infty} \left[ -\frac{1}{\theta} e^{-\theta t} \right]_{t^+}^{b} =\\
&= \lim_{b \to \infty} \left( -\frac{1}{\theta} e^{-\theta b} + \frac{1}{\theta} e^{-\theta t^+} \right) = \frac{e^{-\theta t^+}}{\theta} = \frac{S(t^+) \cdot t^+}{- \ln S(t^+)}
\end{aligned}
$$
Ostatecznie estymowana wartość oczekiwana obliczana jest ze wzoru:

$$
\hat{\mu} \phantom{cc} = \sum_{i:, t_{(i)} \le t^+} \hat{S}\left(t_{(i)-1}\right)\left(t_{(i)} - t_{(i-1)}\right) - \frac{S(t^+) \cdot t^+}{\ln S(t^+)}, \quad t_{(0)} := 0, \ \ \hat{S}\left(t_{(0)}\right)=1
$$

Poniżej przedstawiono blok kodu w R obliczający średni czas życia. Parametr `type` pozwala wybrać, czy obliczenia mają być wykonane dla estymatora Kaplana–Meiera czy Fleminga–Harringtona, natomiast parametr `tail` określa, czy ma być uwzględniony ogon wykładniczy według propozycji Browna, Hollandera i Kowara.

```{r zycie-mnie-mnie}
expected.life <- function(df, type = "kaplan-meier", tail = FALSE) {
  fit <- survfit(Surv(df$times, df$deltas) ~ 1, type = type)

  df.complete <- data.frame(time = c(0, fit$time),
                            surv = c(1, fit$surv))
  
  # dyskretna całka
  dt <- diff(df.complete$time)
  surv_val <- head(df.complete$surv, -1)
  integral_KM <- sum(surv_val * dt)
  
  # ogon wykładniczy
  if (tail) {
    t_plus <- tail(df.complete$time, 1)
    S_plus <- tail(df.complete$surv, 1)
    theta <- -log(S_plus) / t_plus
    tail_integral <- S_plus / theta
    return(integral_KM + tail_integral)
  }
  
  return(integral_KM)
}
```

## Zadanie 2

Zadanie polega na wykorzystaniu napisanej w poprzednim zadaniu funkcji do oszacowania średniego czasu do emisji choroby pacjentów leczonym lekiem A i lekiem B na podstawie danych z zadania 3 z listy 2.

Wyniki przedstawiono w tabelach poniżej.

```{r choroba, echo=FALSE}
mean_times <- data.frame(
  a = c(
    expected.life(df.A, type = "kaplan-meier", tail = TRUE),
    expected.life(df.A, type = "fleming-harrington", tail = TRUE)
  ),
  b = c(
    expected.life(df.B, type = "kaplan-meier", tail = TRUE),
    expected.life(df.B, type = "fleming-harrington", tail = TRUE)
  )
)

rownames(mean_times) <- c("Kaplan-Meier", "Fleming-Harrington")
kable(mean_times, 
      digits = 3, 
      row.names = TRUE,
      col.names = c("Lek A", "Lek B"),
      caption = "\\label{tab:choroba} Średni czas życia estymowany metodami Kaplana-Meiera oraz Fleminga-Harringtona")
```

\hyperref[tab:choroba]{Tabela \ref*{tab:choroba}.} przedstawia średni czas życia estymowany metodami Kaplana–Meiera oraz Fleminga–Harringtona. W obu grupach estymatory wskazują, że średni czas życia w grupie przyjmującej lek A jest większy niż w grupie przyjmującej lek B. Estymator Fleminga-Harringtona zwraca nieco wyższe wartości średniego czasu życia niż estymator Kaplana–Meiera, co wynika z samej konstrukcji estymatora i sposobu ważenia obserwacji cenzurowanych.

\newpage
# Lista 7

Lista polega na napisaniu funkcji która na podstawie danych cenzurowanych losowo oblicza dolną i górną granicę przedziału ufności dla średniego czasu życia na zadanym poziomie ufności $1-\alpha$ oraz dla określonej wartości $\tau$, która odzwierciedla naszą wiedzę a priori o maksymalnym czasie do wystąpienia zdarzenia. Następnie, wykorzystując rzeczywiste dane z badania Mayo Clinic dotyczące czasu do progresji choroby w dwóch grupach pacjentek, zastosowano tę funkcję do wyznaczenia przedziałów ufności dla wybranych wartości $\tau$ i porównano otrzymane wyniki między grupami.

## Zadanie 1

Zadanie polega na zdefiniowaniu funkcji, która dla zadanych danych, poziomu istotności $\alpha$ oraz wartości $\tau$ (odzwierciedlającej naszą wiedzę a priori o maksymalnym czasie do wystąpienia zdarzenia) zwraca dolną i górną granicę przedziału ufności dla średniego czasu życia, na poziomie ufności $1-\alpha$.

Do wyznaczenia przedziałów ufności korzystamy z twierdzenia że, jeśli $F$ i $G$ są dystrybuantami odpowiednio czasu życia i czasu cenzurowania, ciągłymi na przedziale $[0,T]$, a ponadto $F(T) < 1$, to zachodzi zbieżność

$$
\frac{\hat\mu_\tau - \mu}{\sqrt{\widehat V(\hat\mu_\tau)}} \xrightarrow{d} N(0,1).
$$

Wynika z tego, że przedział ufności postaci $[T_L, T_U]$, gdzie

$$
T_L = \hat\mu_\tau - z(1-\alpha/2)\sqrt{\widehat V(\hat\mu_\tau)},
$$

$$
T_U = \hat\mu_\tau + z(1-\alpha/2)\sqrt{\widehat V(\hat\mu_\tau)},
$$

jest asymptotycznym punktowym przedziałem ufności dla wartości średniej $\mu$ rozkładu czasu życia na poziomie ufności $1-\alpha$. Zmienna $z(q)$ oznacza kwantyl rzędu $q$ standardowego rozkładu normalnego.

Estymator $\hat\mu_\tau$ średniego czasu życia ograniczonego do punktu $\tau$ (restricted mean survival time) jest definiowany jako:

$$
\hat\mu_\tau = \int_0^\tau \hat S(t)dt,
$$

gdzie $\hat S(t)$ oznacza estymator Kaplan–Meiera funkcji przeżycia.

Wariancja estymatora $\hat\mu_\tau$ jest przybliżana za pomocą wzoru:

$$
\widehat V(\hat\mu_\tau)
= \sum_{i=1}^{D}\left(\int_{s_i}^{\tau}\widehat S(t)\,\mathrm{d}t\right)^2
\frac{d_i}{r_i(r_i - d_i)}.
$$

gdzie

$$
r_i = \sum_{j=1}^n \mathbf{1}_{[t_{(i)},\infty)}(t_j)\qquad
d_i = \sum_{j=1}^n \mathbf{1}_{\{t_{(i)}\}}(t_j)\,\mathbf{1}_{\{1\}}(\delta_j),
$$

a $D$ oznacza liczbę zaobserwowanych (niecenzurowanych) zdarzeń, natomiast $s_i = t_{(i)}$ jest $i$-tą statystyką pozycyjną czasów zdarzeń.

Wielkość $r_i$ to liczba jednostek znajdujących się w stanie ryzyka w chwili $t_{(i)}$, czyli obserwacji, które dotrwały do tego czasu bez wcześniejszego zdarzenia lub cenzurowania. Z kolei $d_i$ to liczba (niecenzurowanych) zdarzeń występujących dokładnie w chwili $t_{(i)}$.

Poniżej przedstawiono blok kodu w języku R zawierający funkcję, która oblicza wartości $\int_{s_i}^{\tau} \hat S(t),dt$ oraz estymator wariancji $\widehat V(\hat\mu_\tau)$, a następnie wyznacza granicę dolną $T_L$ i górną $T_U$ asymptotycznego przedziału ufności dla średniego czasu życia, dla zadanego zbioru danych, poziomu istotności $\alpha$ oraz wartości $\tau$.

```{r przedzialy_ufnosci}
integrate.S <- function(df, a, b) {
  
  fit <- survfit(Surv(df$times, df$deltas) ~ 1)
  event_idx <- which(fit$n.event > 0)
  
  df.complete <- data.frame(
    time = c(0, fit$time[event_idx]),
    surv = c(1, fit$surv[event_idx])
  )
  
  Time <- df.complete$time
  Surv <- df.complete$surv
  
  # a za ostatnim skokiem - całkowanie po stałej wartości
  if (a >= tail(Time, 1))
    return((b - a) * tail(Surv, 1))
  
  # Pierwszy punkt > a
  t_idx_candidates <- which(Time > a)
  t_idx <- min(t_idx_candidates)
  prev_idx <- max(1, t_idx - 1) # KM(a) = wartość z poprzedniego skoku
  
  # pierwszy fragment całki: od a do najbliższego punktu siatki
  integral_S <- Surv[prev_idx] * (Time[t_idx] - a)
  
  # b przed ostatnim skokiem
  if (b <= tail(Time, 1)) {
    # ostatni punkt < b
    T_idx_candidates <- which(Time < b)
    T_idx <- max(T_idx_candidates)
    
    # fragment końcowy: od ostatniego punktu < b do b
    integral_S <- integral_S + Surv[T_idx] * (b - Time[T_idx])
    
    dt <- diff(df.complete$time)
    surv_val <- head(df.complete$surv, -1)
    
    # środkowa część sumy prostokątów
    if (T_idx - 1 >= t_idx)
      integral_S <- integral_S + sum(surv_val[t_idx:(T_idx - 1)] * dt[t_idx:(T_idx - 1)])
    
  } else {
    # jeżeli b poza zakresem KM - dopisujemy punkt (b, S_last)
    df.complete <- rbind(df.complete, data.frame(time = b, surv = tail(Surv, 1)))
    dt <- diff(df.complete$time)
    surv_val <- head(df.complete$surv, -1)
    
    # całkowanie po całej reszcie przedziału
    integral_S <- integral_S + sum(surv_val[t_idx:length(surv_val)] * dt[t_idx:length(dt)])
  }
  
  return(integral_S)
}

var.estimator <- function(df, tau) {
  Time <- df$times
  Deltas <- df$deltas
  event_times <- sort(unique(Time[Deltas == 1]))
  result <- 0
  
  for (i in 1:length(event_times)) {
    t_i <- event_times[i]
    d <- 0
    r <- sum(Time >= t_i)
    for (j in 1:length(Time)) {
      if (Time[j] == t_i & Deltas[j] == 1) {
        d <- d + 1
      }
    }
    if (r > d)
      result <- result + (integrate.S(df, t_i, tau))^2 * d/(r * (r - d))
  }
  return(result)
}

confidence.interval <- function(df, alfa, tau) {
  mu <- integrate.S(df, 0, tau)
  kwantyl <- qnorm(1 - alfa /2)
  std.dev <- sqrt(var.estimator(df, tau))
  T_L <- mu - kwantyl * std.dev
  T_U <- mu + kwantyl * std.dev
  return(data.frame(T_L = T_L, T_U = T_U))
}
```

## Zadanie 2

Zadanie polega na wyznaczeniu realizacji przedziałów ufności, na poziomie ufności $0.95$ ($\alpha = 0.05$), dla średniego czasu do progresji choroby w dwóch grupach pacjentek kliniki Mayo Clinic, obejmujących pacjentki chore na raka jajnika w II oraz IIIA stadium choroby.

W przypadku pacjentek w stadium II czasy (w dniach) do progresji choroby były następujące:  28, 89, 175, 195, 309, 377+, 393+, 421+, 447+, 462, 709+, 744+, 770+, 1106+ ,1206+. Symbol „$+$” oznacza obserwację prawostronnie cenzurowaną.

Dla pacjentek w stadium IIIA czasy (w dniach) wynosiły: 34, 88, 137, 199, 280, 291, 299+, 300+, 309, 351, 358, 369, 369, 370, 375, 382, 392, 429+, 451, 1119+.

Ze względu na fakt, że progresja chorób nowotworowych zależy od wielu czynników, w szczególności indywidualnych, trudno jest ustalić jednoznacznie "sensowne" maksymalne czasy do progresji choroby. Dlatego przedziały ufności wyznaczono dla dwóch wartości parametru $\tau$: $\tau = 1460$ oraz $\tau = 1825$, odpowiadających odpowiednio 4 i 5 latom (przy przyjęciu uproszczenia: 1 rok = 365 dni). Następnie porównano uzyskane przedziały ufności dla obu grup i obu wartości $\tau$.


``` {r raki}
times.II <- c(28, 89, 175, 195, 309, 377, 393, 421, 447, 462, 709, 744, 770, 
              1106, 1206)
deltas.II <- c(1,1,1,1,1,0,0,0,0,1,0,0,0,0,0)
df.II <- data.frame(times = times.II, deltas = deltas.II)

times.III <- c(34, 88, 137, 199, 280, 291, 299, 300, 309, 351, 358, 369, 369, 
               370, 375, 382, 392, 429, 451, 1119)
deltas.III <- c(1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,1,0)
df.III <- data.frame(times = times.III, deltas = deltas.III)

tau = 1460
Ci_II_1 <- confidence.interval(df.II, 0.05, tau)
Ci_III_1 <- confidence.interval(df.III, 0.05, tau)

tau = 1825
Ci_II_2 <- confidence.interval(df.II, 0.05, tau)
Ci_III_2 <- confidence.interval(df.III, 0.05, tau)
```

```{r nieboraki1, echo=FALSE}
raki1 <- data.frame(
  a = c(Ci_II_1$T_L, Ci_III_1$T_L),
  b = c(Ci_II_1$T_U, Ci_III_1$T_U))
rownames(raki1) <- c("Typ II", "Typ IIIA")

kable(raki1, 
      digits = 3, 
      row.names = TRUE,
      col.names = c("Grupa", "$T_L$", "$T_U$"),
      caption = "\\label{tab:raki1} Realizacje przedziałów przeżycia dla pacjentek z rakiem jajnika typu II i typu IIIA - Mayo Clinic - $\\tau = 1460$")
```

Z \hyperref[tab:raki1]{Tabeli \ref*{tab:raki1}} wynika, że przedział ufności dla pacjentek z rakiem typu II jest szerszy niż dla pacjentek z rakiem typu IIIA. Prawdopodobnie wynika to z faktu, że grupa typu II obejmuje mniej zarejestrowanych obserwacji, w tym mniej obserwacji kompletnych. Dodatkowo, niższe stadium choroby charakteryzuje się większymi wartościami czasu - różnica między minimalną wartością dla typu II a maksymalną dla typu IIIA wynosi zaledwie `r round(Ci_III_1$T_U, 3) - round(Ci_II_1$T_L, 3)`. Obserwacja ta odpowiada rzeczywistym danym: wyższy stopień zaawansowania nowotworu wiąże się z szybszą progresją choroby.

```{r nieboraki2, echo=FALSE}
raki2 <- data.frame(
  a = c(Ci_II_2$T_L, Ci_III_2$T_L),
  b = c(Ci_II_2$T_U, Ci_III_2$T_U))
rownames(raki2) <- c("Typ II", "Typ IIIA")

kable(raki2, 
      digits = 3, 
      row.names = TRUE,
      col.names = c("Grupa", "$T_L$", "$T_U$"),
      caption = "\\label{tab:raki2} Realizacje przedziałów przeżycia dla pacjentek z rakiem jajnika typu II i typu IIIA - Mayo Clinic - $\\tau = 1825$")
```

Z \hyperref[tab:raki2]{Tabeli \ref*{tab:raki2}} można odczytać odmienne zachowanie przedziałów ufności dla poszczególnych grup. W przypadku pacjentek z nowotworem typu II zarówno dolna, jak i górna granica przedziału wzrosły, przy czym górna granica zwiększyła się wyraźnie bardziej niż dolna. W przypadku raka typu IIIA górna granica również wzrosła, natomiast dolna uległa obniżeniu. Zmiany w grupie typu IIIA są mniejsze niż w grupie typu II, co sugeruje bardziej stabilne zachowanie estymatora funkcji przeżycia w ogonie rozkładu.

Analizując estymacje można zauważyć, że dla raka typu II wartość czasu przeżycia była większa niż jego wariancja, natomiast dla typu IIIA sytuacja była odwrotna. Wspólną cechą obu grup jest wydłużenie przedziałów ufności, co wskazuje na zwiększoną niepewność estymacji przy dłuższym czasie obserwacji.

\newpage
# Lista 8

Lista polega na weryfikacji hipotezy o jednakowym rozkładzie czasu do progresji choroby w dwóch badanych grupach pacjentek, przy użyciu testów logrank, Gehana-Breslowa, Tarone’a-Warego i Peto-Peto, porównaniu otrzymanych wartości poziomów krytycznych oraz na naszkicowaniu wykresów estymatorów Kaplana-Meiera funkcji przeżycia dla czasu do progresji choroby w obu grupach wraz z funkcjami wagowymi użytymi w statystykach testowych.

## Zadanie 1

W zadaniu dokonano wyliczenia wartości $p$-value dla hipotezy o jednakowym rozkładzie czasu do progresji choroby w dwóch badanych grupach pacjentek, z podziałem na sposób dobierania wagi.

Na początek łączymy poszczególne próby $\mathbb{X}_1,\dots,\mathbb{X}_k$, gdzie $\mathbb{X}_j = (X_{j1},\dots,X_{jn_j})$, $j \in \{1,\dots,k\}$. Z tak połączonych grup wyznaczamy (unikalne) czasy zdarzeń, których liczbę oznaczamy przez $D$, i porządkujemy je rosnąco: $t_1 < t_2 < \dots < t_D$.

Statystyka testowa opiera się na sumie ważonych różnic między oszacowanymi hazardami w momentach $t_i$. Oszacowania te wyznaczane są za pomocą estymatora Nelsona--Aalena funkcji hazardu:

$$
Z_j(\tau) = \sum_{i=1}^D W_j(t_i) \left( \frac{d_{ij}}{r_{ij}} - \frac{d_i}{r_i} \right), \quad \text{gdzie:}
$$

\begin{itemize}
\item $d_{ij}$ -- liczba zdarzeń w czasie $t_i$ z próby $\mathbb{X}_j$,
\item $r_{ij}$ -- liczba jednostek w stanie ryzyka w czasie $t_i$ w $j$-tej grupie,
\item $d_i = \sum_{j=1}^k d_{ij}$,
\item $r_i = \sum_{j=1}^k r_{ij}$.
\end{itemize}

W zadaniu przyjęto funkcję wagi jako $W_j(t_i)=r_{ij}W(t_i)$, wtedy statystyka $Z_j(\tau)$ ma postać:

$$
Z_j(\tau) = \sum_{i=1}^D W(t_i)\left(d_{ij} - r_{ij}\frac{d_i}{r_i}\right).
$$

Wariancję takiej statystyki estymujemy przez:

$$
\hat{\sigma}_{jj} = \sum_{i=1}^D
W^2(t_i)d_i\frac{r_{ij}}{r_i}\left(1 - \frac{r_{ij}}{r_i}\right)\left(\frac{r_i - d_i}{r_i - 1}\right),
$$

kowariancję natomiast szacujemy jako:

$$
\hat{\sigma}_{jg} = - \sum_{i=1}^D
W^2(t_i)d_i\frac{r_{ij}r_{ig}}{r_i^2}\left(\frac{r_i - d_i}{r_i - 1}\right).
$$

Statystyka testowa do weryfikacji rozpatrywanych hipotez konstruowana jest w oparciu o dowolne $k-1$ wybranych statystyk $Z_j(\tau)$ i ma postać:

$$
Z^2 = \left(Z_1(\tau),\dots,Z_{k-1}(\tau)\right) \Sigma^{-1} \left(Z_1(\tau),\dots,Z_{k-1}(\tau)\right)^T,
$$

gdzie macierz $\Sigma$ jest utworzona z odpowiednich elementów $\hat{\sigma}_{jj}$ oraz $\hat{\sigma}_{jg}$.

Udowodniono, że jeżeli hipoteza $H_0$ jest spełniona, to rozkład statystyki $Z^2$ dąży według rozkładu do rozkładu chi-kwadrat z $k-1$ stopniami swobody, gdy $n_1 \to \infty,\dots,n_{k-1} \to \infty$. Korzystając z tego faktu, można obliczyć wartość poziomu krytycznego:

$$
p = 1 - F_{\chi^2_{k-1}}(z^2),
$$

gdzie $F_{\chi^2_{k-1}}$ jest dystrybuantą rozkładu chi-kwadrat z $k-1$ stopniami swobody, a $z^2$ realizacją statystyki $Z^2$.

W zadaniu dokonano czterech testów ze względu na dobraną postać funkcji $W(t_i)$:

* test logrank: $W(t_i) \equiv 1$,
* test Gehana--Breslowa: $W(t_i)=r_i$,
* test Peto--Peto: $W\left(t_i\right)=\prod_{t_j \leq t_i} \left(1-\frac{d_j}{r_j+1}\right)$,
* test Tarone'a--Ware'a: $W(t_i)=\sqrt{r_i}$.

```{r testy-tabela, echo=FALSE}
df.II$progresja <- "lekka"
df.III$progresja <- "mocna"
df.cancer <- data.frame(rbind(df.II, df.III))
df.cancer$progresja <- as.factor(df.cancer$progresja)

lg <- logrank_test(Surv(times, deltas) ~ progresja,
                   data=df.cancer, type="logrank")
GB <- logrank_test(Surv(times, deltas) ~ progresja,
                   data=df.cancer, type="Gehan-Breslow")
PP <- logrank_test(Surv(times, deltas) ~ progresja,
                   data=df.cancer, type="Peto-Peto")
TW <- logrank_test(Surv(times, deltas) ~ progresja,
                   data=df.cancer, type="Tarone-Ware")

df <- data.frame("$p$-value"=c(pvalue(lg),
                               pvalue(GB),
                               pvalue(PP),
                               pvalue(TW)))

rownames(df) <- c("logrank", "Gehan-Breslow", "Peto-Peto", "Tarone-Ware")

kable(df, row.names=TRUE, digits=3, escape=FALSE, col.names = c("Test", "p-value"), caption="\\label{tab:nieboraki} Wartości $p$-value dla testów czasu do progresji choroby weryfikujących hipotezę o jednakowym rozkładzie w grupach pacjentek rakowych kliniki Mayo Clinic")
```


Z \hyperref[tab:nieboraki]{Tabeli \ref*{tab:nieboraki}} wynika, że na ustalonym poziomie istotności $\alpha = 0.05$ hipoteza o jednakowym rozkładzie czasu do progresji powinna zostać odrzucona jedynie w przypadku testu logrank. Wartości $p$-value dla poszczególnych funkcji wag różnią się między sobą, co wynika bezpośrednio z ich konstrukcji:

* **logrank** traktuje wszystkie zdarzenia równoważnie, wykrywając globalne różnice między grupami, nawet jeśli ujawniają się one późno,
* **Gehan-Breslow** przypisuje większą wagę wcześniejszym czasom - jeżeli różnice między grupami pojawiają się późno, test staje się na nie mniej wrażliwy,
* **Tarone-Ware** jest kompromisem między logrank a Gehan-Breslow - zmniejsza różnice między wagami, nakładając na nie pierwiastek,
* **Peto-Peto** dla poszczególnych czasów uwzględnia nie tylko aktualne zdarzenie, ale również wszystkie wcześniejsze oraz informację o liczbie zdarzeń w połączonych próbach, które wystąpiły w tym samym czasie.

Podsumowując, istotność wykazana przez test logrank wskazuje na globalną różnicę w przebiegu czasu do zdarzenia między grupami, natomiast brak istotności w pozostałych testach odzwierciedla fakt, że lokalne lub czasowo rozłożone różnice są mniej wyraźne.

## Zadanie 2

Zadanie polega na naszkicowaniu wykresów estymatorów Kaplana–Meiera funkcji przeżycia dla dwóch grup oraz unormowanych funkcji wagowych testów logrank, Gehan-Breslow, Tarone-Ware i Peto-Peto. Na podstawie wykresów należy przeanalizować, jak kształt funkcji przeżycia i przypisane wagi wpływają na wartości $p$-value oraz wnioski dotyczące istotności różnic między grupami.

Poniżej przedstawiono blok kodu w R, który oblicza dla każdego zaobserwowanego czasu zdarzenia liczby jednostek w stanie ryzyka i liczby zdarzeń, a następnie na ich podstawie generuje unormowane funkcje wag.

```{r testy-wykres_przygotowanie}
# Uzupełnienie danych o wartości r_i i d_i
df.cancer$r <- 0
df.cancer$d <- 0
for(i in 1:nrow(df.cancer)){
  df.cancer[i, "r"] <- sum(df.cancer$times >= df.cancer[i, "times"])
  df.cancer[i, "d"] <- sum(df.cancer$times == df.cancer[i, "times"] &
                           df.cancer$deltas==1)
}

# Unikalne zdarzenia
df.cancer_unique <- df.cancer[!duplicated(df.cancer$times) &
                           df.cancer$deltas==1,]

# Wagi testu logrank
df.cancer_unique$lg <- 1

# Wagi testu Gehana-Breslowa
df.cancer_unique$GB <- df.cancer_unique$r

# Wagi testu Peto-Peto
df.cancer_unique$PP <- 0
for(i in 1:nrow(df.cancer_unique)){
  czas <- df.cancer_unique[i, "times"]
  iloczyn <- 1
  for(j in 1:nrow(df.cancer_unique)){
    if(df.cancer_unique[j, "times"] <= czas){
      dj <- df.cancer_unique[j, "d"]
      rj <- df.cancer_unique[j, "r"]
      iloczyn <- iloczyn * (1 - dj/(rj + 1))
    }
  }
  df.cancer_unique[i, "PP"] <- iloczyn
}

# Wagi testu Tarone'a-Were'a
df.cancer_unique$TW <- sqrt(df.cancer_unique$r)

# Unormowanie wag
df.cancer_unique$lg <- df.cancer_unique$lg/sum(df.cancer_unique$lg)
df.cancer_unique$GB <- df.cancer_unique$GB/sum(df.cancer_unique$GB)
df.cancer_unique$PP <- df.cancer_unique$PP/sum(df.cancer_unique$PP)
df.cancer_unique$TW <- df.cancer_unique$TW/sum(df.cancer_unique$TW)
```

```{r testy-wykres, echo=FALSE, fig.cap="\\label{fig:udbzddp} Wagi testów nieparametrycznych dla porównania rozkładów czasów przeżycia - Mayo Clinic"}
ggplot(df.cancer_unique, aes(x = times)) +
  geom_line(aes(y = lg, color = "logrank"), linewidth = 1.2) +
  geom_line(aes(y = GB, color = "Gehan-Breslow"), linewidth = 1.2) +
  geom_line(aes(y = PP, color = "Peto-Peto"), linewidth = 1.2) +
  geom_line(aes(y = TW, color = "Tarone-Ware"), linewidth = 1.2) +
  scale_color_manual(values = c("logrank"="tomato", 
                                "Gehan-Breslow"="steelblue",
                                "Tarone-Ware"="darkgreen", 
                                "Peto-Peto"="wheat")) +
  labs(x = "Czas do progresji (t)", 
       y = "Unormowana funkcja wagowa W(t)", 
       color = "Test") +
  theme_minimal() +
  theme(legend.position = "bottom")

```

Na \hyperref[fig:testy-wykres]{Wykresie \ref*{fig:testy-wykres}} widać, jakie unormowane wagi przypisuje każdy z testów dla poszczególnych czasów. Dla $t \approx 320$ wagi testów Gehan-Breslow, Peto-Peto i Tarone-Ware przecinają krzywą wag testu logrank, co oznacza, że dla zdarzeń o czasie większym niż 320 przypisywane jest mniejsze znaczenie niż przy teście logrank.

```{r Kaplan-Meier-rak, echo=FALSE, fig.cap="Estymator Kaplana-Meiera dla danych dotyczących pacjentek z rakiem jajnika - Mayo Clinic", warning=FALSE}
surv.II <- Surv(df.II$times, df.II$deltas)
surv.IIIA <- Surv(df.III$times, df.III$deltas)

# Estymator Kaplana-Meiera
fit.KM.II <- survfit(surv.II ~ 1)
fit.KM.IIIA <- survfit(surv.IIIA ~ 1)

# Ramki danych do wykresu
plot.II <- data.frame(time = c(0, fit.KM.II$time), 
                     surv = c(1, fit.KM.II$surv), 
                     group = "II")

plot.IIIA <- data.frame(time = c(0, fit.KM.IIIA$time), 
                     surv = c(1, fit.KM.IIIA$surv), 
                     group = "IIIA")

plot.df  <- rbind(plot.II, plot.IIIA)

max.time <- max(max(df.II$times[df.II$deltas==1]),
                max(df.III$times[df.III$deltas==1]))

ggplot(plot.df, aes(x = time, y = surv, color = group)) +
  geom_step(linewidth = 1.2) +
  scale_color_manual(values = c("II" = "steelblue", "IIIA" = "tomato"),
                     labels = c("II", "IIIA")) +
  scale_y_continuous(limits = c(0,1)) +
  labs(x = "Czas do progresji (t)",
       y = expression(hat(S)(t)),
       color = "Typ nowotworu") +
  scale_x_continuous(limits = c(0, max.time)) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

Na \hyperref[fig:Kaplan-Meier-rak]{Wykresie \ref*{fig:Kaplan-Meier-rak}.} można zauważyć, że estymatory przeżycia Kaplana-Meiera dla obu zbiorów danych pacjentek rakowych są dość zbliżone do czasu $t \approx 320$. Po tym punkcie funkcje przeżycia gwałtownie spadają, co oznacza, że w tym okresie występuje progresja choroby dla wielu pacjentek. To skutkuje spadkiem wag testów Gehan-Breslow, Peto-Peto i Tarone-Ware w późniejszych momentach czasu, co oznacza, że późne zdarzenia mają mniejszy wpływ na wartość statystyki testowej w porównaniu do testu logrank. W konsekwencji główny wkład do obliczenia wartości $p$ pochodzi ze zdarzeń występujących wcześniej, zanim funkcje przeżycia drastycznie spadną.

Ze względu na spadek wag testów Gehan-Breslow, Peto-Peto i Tarone-Ware dla późnych czasów, istotność statystyczna opiera się głównie na wcześniejszych zdarzeniach. W tym przypadku najbardziej reprezentatywne jest $p$‑value z testu logrank, który równomiernie uwzględnia wszystkie zdarzenia, co widać na \hyperref[fig:Kaplan-Meier-rak]{Wykresie \ref*{fig:Kaplan-Meier-rak}.} estymatorów Kaplana-Meiera.

\newpage
# Zadania dodatkowe

## Zadanie 1

```{r, echo=TRUE}
cenzurowanie_losowe <- function(theta, data) {
  censor_data <- rexp(length(data), rate=theta)
  deltas <- as.numeric(data <= censor_data)
  censored_data <- ifelse(data <= censor_data, data, censor_data)
  list(times = censored_data, deltas = deltas)
}

GE_cenzurowanie_losowe <- function(theta, alpha, lambd, n) {
  data <- EW_generator(alpha = 1, beta = lambd, gamm = alpha, size = n)
  cenzurowanie_losowe(theta, data)
}
```

## Zadanie 2

Estymatory Kaplana-Meiera oraz Fleminga–Harringtona są funkcjami schodnowymi. W stosunkowo małych próbach często obserwuje się szerokie przedziały czasu w których estymator jest stały - praktycznie i interpretacyjnie bywa to niepożądane i statystykom trudno jest wytłumaczyć praktykom na przykładzie \hyperref[fig:KM-plot]{Wykresu \ref*{fig:KM-plot}.} grupy leku A dlaczego prawdopodobieńsgtwo przeżycia do chwili $t = 0.7$ jest równe prawdopodobieństwu przeżycia do chwili $t = 0.8$.

Rossa i Zieliński \cite{rossa2002} zaproponowali lokalne „wygładzenie” estymatora Kaplana–Meiera poprzez dopasowanie funkcji gęstości rozkładu Weibulla w niewielkim otoczeniu każdego punktu skoku.

**Zasada działania estymatora**

**Krok 1.** Konstrukcja wartości środkowych

1. Niech $T_{0} = 0$ oraz $KM(T_{0}) = 1$, a
   $$
   T_{(1)} < T_{(2)} < \dots < T_{(N-1)}
   $$
   będą uporządkowanymi czasami obserwacji, gdzie $T_{(1)}, \dots, T_{(N-1)}$ oznaczają momenty skoków klasycznego estymatora Kaplana–Meiera, natomiast $T_{(N)}$ jest ostatnim czasem w próbie (zdarzeniem lub cenzurowaniem).
   Wartości $KM\left(T_{(j)}\right)$ oznaczają wartość estymatora Kaplana–Meiera w chwili $T_{(j)}$, tj. tuż po wystąpieniu skoku.

2. Dla każdego $j = 1,\dots,N-1$ wartość środkową definiuje się jako średnią arytmetyczną dwóch kolejnych wartości estymatora:
   $$
   KM'_j = \frac{KM\left(T_{(j-1)}\right) + KM\left(T_{(j)}\right)}{2}.
   $$

3. W przypadku ostatniego czasu skoku $T_{(N)}$ wartość $KM'_N$ definiuje się jako:
   $$
   KM'_N =
   \begin{cases}
   \dfrac{KM\left(T_{(N)}\right)}{2}, & \delta_N = 1, \\
   KM\left(T_{(N)}\right), & \delta_N = 0.
   \end{cases}
   $$

**Krok 2.** Obliczanie wag

Dla dowolnego $t\ge 0$ definiujemy wektor wag
$$
\mathbf{w}(t)=\left(w_1(t),\dots,w_N(t)\right).
$$
Wagi zależą od parametru $m$ — liczby "sąsiadów" (liczb całkowitych) — oraz od położenia $t$ względem przedziałów między momentami skoków estymatora. Wagi te będą użyte w następnych krokach przy regresji liniowej.

Rozróżniamy trzy przypadki dla różych $m$:

A) Gdy $m=2$ wagi są zawsze "punktowe", a sam estymator przyjmuje odmienną, uproszczoną postać. Szczegóły przedstawiono w dalszej części.

B) Gdy $m$ jest nieparzyste tzn. $m=2k+1$ dla pewnego $k\in\mathbb{N}$. Wagi definiujemy następująco:

Zdefiniujmy najpierw indeks $j$ opisujący, w którym przedziale znajduje się $t$:

$$
j =
\begin{cases}
0, & t \le T_{(1)}, \\
N, & t > T_{(N)}, \\
i\in{1,\dots,N-1}, & T_{(i)} < t \le T_{(i+1)}
\end{cases}
$$

1. Jeżeli $j \le k$ (t blisko początku) - krawedź lewa:

$$
w_1(t)=w_2(t)=\dots=w_m(t)=1,
$$
oraz
$$
w_{m+1}(t)=\dots=w_N(t)=0.
$$
2. Jeżeli $j\ge N-k$ (t blisko końca) - krawedź prawa:

$$
w_{N-m+1}(t)=w_{N-m+2}(t)=\dots=w_N(t)=1,
$$
oraz
$$
w_1(t)=\dots=w_{N-m}(t)=0.
$$
3. Jeżeli $k< j < N-k$ ($t$ jest dostatecznie daleko od krawedzi i otoczenie o rozmiarze $m$ mieści się w zakresie indeksów) - przypadek środkowy:

1. Blok jednostkowy (dokładnie $m$ indeksów)
   Dla indeksów $i\in{j-k,j-k+1,\dots,j+k}$ przyjmujemy $w_i(t)=1.$

2. Dwa brzegowe indeksy sąsiednie (ewentualne wagi ułamkowe)
   Jeśli istnieje indeks lewy ($j - k \ge 1$)
   $$
   i_{\text{lewy}} = j-k,
   $$
   to jego waga zależy liniowo od położenia $t$ w przedziale $(T_{(j)},T_{(j+1)}]$:
   $$
   w_{i_{\text{lewy}}}(t)=\frac{T_{(j+1)}-t}{T_{(j+1)}-T_{(j)}}.
   $$
   Jeśli istnieje indeks prawy ($j+k+1\le N)$)
   $$
   i_{\text{prawy}} = j+k+1,
   $$
   to jego waga wynosi
   $$
   w_{i_{\text{prawy}}}(t)=\frac{t-T_{(j)}}{T_{(j+1)}-T_{(j)}}.
   $$

3. Pozostałe wagi

   Wszystkie pozostałe składowe wektora wag przyjmują wartość $0$.

Gdy $m$ jest parzyste tzn. $m=2k$ dla pewnego $k\in\mathbb{N_+}$. Wagi definiujemy następująco:

Zdefiniujmy najpierw indeks $j$ opisujący, w którym przedziale znajduje się $t$:

$$
j =
\begin{cases}
0, & t \le T_{(1)} / 2, \\
N, & t > (T_{(N-1)} + T_{(N)}) / 2, \\
i\in{1,\dots,N-1}, & \left(T_{(i-1)}+T_{(i)}\right)/2 < t \le \left(T_{(i)}+T_{(i+1)}\right)/2
\end{cases}
$$
1. Jeżeli $j \le k$ (t blisko początku) - krawedź lewa:

$$
w_1(t)=w_2(t)=\dots=w_m(t)=1,
$$
oraz
$$
w_{m+1}(t)=\dots=w_N(t)=0.
$$
2. Jeżeli $j\ge N-k+1$ (t blisko końca) - krawedź prawa:

$$
w_{N-m+1}(t)=w_{N-m+2}(t)=\dots=w_N(t)=1,
$$
oraz
$$
w_1(t)=\dots=w_{N-m}(t)=0.
$$

3. Jeżeli $k< j < N-k+1$ ($t$ jest dostatecznie daleko od krawedzi i otoczenie o rozmiarze $m$ mieści się w zakresie indeksów) - przypadek środkowy:

1. Blok jednostkowy (dokładnie $m$ indeksów)
   Dla indeksów $i\in{j-k+1,j-k+2,\dots,j+k}$ przyjmujemy $w_i(t)=1.$

2. Dwa brzegowe indeksy sąsiednie (ewentualne wagi ułamkowe)
   Jeśli istnieje indeks lewy ($j - k \ge 1$)
   $$
   i_{\text{lewy}} = j-k,
   $$
   to jego waga zależy liniowo od położenia $t$ w przedziale $(T_{(j)},T_{(j+1)}]$:
   $$
   w_{i_{\text{lewy}}}(t)= \frac{\frac{1}{2} \left(T_{(j)} + T_{(j+1)}\right)-t}{\frac{1}{2}\left(T_{(j+1)}-T_{(j-1)}\right)}.
   $$
   Jeśli istnieje indeks prawy ($j+k\le N)$)
   $$
   i_{\text{prawy}} = j+k,
   $$
   to jego waga wynosi
   $$
   w_{i_{\text{prawy}}}(t)=\frac{t-\frac{1}{2} \left(T_{(j)} + T_{(j+1)}\right)}{\frac{1}{2}\left(T_{(j+1)}-T_{(j-1)}\right)}.
   $$

3. Pozostałe wagi

   Wszystkie pozostałe składowe wektora wag przyjmują wartość $0$.

**Krok 3.** Interpolacja liniowa oraz ważona regresja liniowa

W pierwszej kolejności obliczamy log-czasy zdarzeń oraz ich log-log przeżycia, które następnie stanowią dane wejściowe do lokalnej regresji liniowej budującej estymator Rossy-Zielińskiego.

$$
X_j = \log T_{(j)}, \qquad
Y_j = \log\left(-\log(KM'_j)\right),
$$
W przypadku $m=2$ i w ustalonej chwili $t$ obliczamy log-t:

$$
X = \log t
$$
Estymator $S_2(t)$ jest liniową transformacją log-log:

$$
Y(t)=
\begin{cases}
Y_{1}
+\dfrac{X_{2}-X_{1}}{\,Y_{2}-Y_{1}\,}(X - X_{1}),& 0 < t \le T_{(1)},\\
Y_{j}+\dfrac{X_{j+1}-X_{j}}{\,Y_{j+1}-Y_{j}\,}(X - X_{j-1}),& T_{(j)} < t \le T_{(j+1)},\\
Y_{N-1}+\dfrac{X_{N}-X_{N-1}}{\,Y_{N}-Y_{N-1}\,}(X - X_{N-1}),& t > T_{(N)} \ \text{ i } \delta_{N}=1,\\
\text{ nieokreślony }, & t > T_{(N)} \ \text{ i } \delta_{N}=0.
\end{cases}
$$

W przypadku $m>2$ i w ustalonej chwili $t$, dysponujemy wektorem wag:

$$
\mathbf{w}(t)=\left(w_1(t),\dots,w_N(t)\right),
$$

Dopasowanie lokalnego modelu Weibulla odbywa się przez zastosowanie ważonej regresji liniowej w przestrzeni transformowanej:

$$
Y_i = a X_i + b + \varepsilon_i,
$$

gdzie parametry $a=a(t)$ i $b=b(t)$ wyznacza się jako rozwiązanie problemu:

$$
\min_{a,b} \sum_{i=1}^N w_i(t)\left[Y_i - (a X_i + b)\right]^2.
$$

Wynikiem są lokalne estymatory:

$$
\widehat{a}(t),\qquad \widehat{b}(t),
$$

które interpretujemy jako lokalne parametry kształtu i skali rozkładu Weibulla dopasowanego w "otoczeniu" punktu "t" przy użyciu wag opisanych wcześniej.

**Krok 4.** Transformacja odwrotna

W przypadku $m=2$ wartość estymatora Rossy-Zielińskiego definuje się jako:

$$
\widehat{S}_2(t) = \exp\left(-\exp(Y(t))\right).
$$

W przypadku $m>2$ rekonstruujemy lokalną funkcję przeżycia, korzystając z postaci funkcji przeżycia rozkładu Weibulla:

$$
S(t) = \exp\left(-\exp(a) t^{b}\right).
$$

Estymator Rossy–Zielińskiego definiuje się jako:

$$
\widehat{S}_m(t) = \exp\left(-\exp\left(\widehat{a}(t)\right)t^{\widehat{b}(t)}
\right).
$$

Otrzymana funkcja jest lokalnie wygładzona, a stopień wygładzenia kontroluje parametr $m$, który określa szerokość okna oraz sposób formowania wag.

Poniżej przedstawiono blok kodu w języku R implementujący estymator Rossy–Zielińskiego wraz z przykładowym generowaniem wykresów funkcji przeżycia.

```{r ross-zielinski}
rossa.zielinski.estimator <- function(df, m = 2) {
  # Funkcja pomocnicza do liczenia wag (dla m > 2)
  compute_weights <- function(Time, t, m) {
    N <- length(Time)
    w <- rep(0, N)
    
    # m = 2k + 1 - nieparzyste
    if (m %% 2 == 1) {
      k <- (m - 1) / 2
      if (t <= Time[1]) {
        j <- 0
      } else if (t > Time[N]) {
        j <- N
      } else {
        j <- max(which(Time < t))
      }
      # generowanie wag
      if (j <= k) {
        w[1:m] <- 1 
      }
      else if (j >= N - k) {
        w[(N - m + 1):N] <- 1
      }
      else {
        idx_unit <- (j - k + 1):(j + k)
        w[idx_unit] <- 1
        # przypadki brzegowe
        if ((j - k) >= 1) {
          w[j - k] <- (Time[j + 1] - t) / (Time[j + 1] - Time[j])
        }
        if ((j + k + 1) <= N) {
          w[j + k + 1] <- (t - Time[j]) / (Time[j + 1] - Time[j])
        }
      }
      # m = 2k - parzyste
    } else {
      k <- m / 2
      if (t <= (Time[1]/2)) {
        j <- 0
      } else if (t > (Time[N-1] + Time[N])/2) {
        j <- N
      } else {
        j <- which((Time[-1] + Time[-N])/2 >= t)[1]
      }
      # generowanie wag
      if (j <= k) {
        w[1:m] <- 1
      } else if (j >= N - k + 1) {
        w[(N - m + 1):N] <- 1
      } else {
        idx_unit <- (j - k + 1):(j + k - 1)
        w[idx_unit] <- 1
        
        # przypadki brzegowe
        if ((j - k) >= 1) {
          w[j - k] <- (0.5*(Time[j] + Time[j + 1]) - t) / 
            0.5 * (Time[j + 1] - Time[j - 1])
        }
        if ((j + k) <= N) {
          w[j + k] <- (t - 0.5*(Time[j - 1] + Time[j])) / 
            0.5 * (Time[j + 1] - Time[j - 1])
        }
      }
    }
    return(w)
  }
  
  # wartości środkowe KM'
  fit <- survfit(Surv(df$times, df$deltas) ~ 1)
  Time <- fit$time[fit$n.event > 0]
  Time <- c(Time, tail(fit$time, 1))
  KM <- fit$surv[fit$n.event > 0]
  KM <- c(KM, tail(fit$surv, 1))
  N <- length(Time)
  
  KM0 <- numeric(N)
  for (i in 1:(N-1)) {
    if (i == 1) {
      KM0[i] <- (1 + KM[i]) / 2
    } else {
      KM0[i] <- (KM[i-1] + KM[i]) / 2
    }
  }
  last_delta <- fit$n.event[which(fit$time == Time[N])]
  if (last_delta == 1) {
    KM0[N] <- KM[N] / 2
  } else {
    KM0[N] <- KM[N]
  }
  
  X <- log(Time)
  Y <- log(-log(KM0))
  
  # Funkcja estymatora
  estimator <- function(x.eval) {
    S <- numeric(length(x.eval))
    
    for (i in seq_along(x.eval)) {
      x <- x.eval[i]
      Xx <- log(x)
      
      # Estymator dla m = 2
      if (m == 2) {
        if (x <= Time[1]) {
          Yx <- Y[1] + (Y[2]-Y[1]) / (X[2]-X[1]) * (Xx - X[1])
        } else if (x > Time[N]) {
          last_delta <- fit$n.event[which(fit$time == Time[N])]
          if (last_delta == 1) {
            Yx <- Y[N-1] + (Y[N]-Y[N-1]) / (X[N]-X[N-1]) * (Xx - X[N-1])
          } else {
            Yx <- NA
          }
        } else {
          j <- max(which(Time < x))
          Yx <- Y[j] + (Y[j+1]-Y[j]) / (X[j+1]-X[j]) * (Xx - X[j])
        }
        if (is.na(Yx)) {
          S[i] <- NA
        } else {
          S[i] <- exp(-exp(Yx))
        }
        
      } else {
        # Klasyczny przypadek m > 2 z wagami i regresją
        w <- compute_weights(Time, x, m)
        reg <- lm(Y ~ X, weights = w)
        a <- coef(reg)[1]
        b <- coef(reg)[2]
        S[i] <- exp(-exp(a) * x^b)
        S[i] <- max(min(S[i],1),0)
      }
    }
    return(S)
  }
  return(estimator)
}

rz.estimator.plot <- function(df, m = 2, to = 3) {
  estimator <- rossa.zielinski.estimator(df, m)
  
  time <- seq(0, to, length.out = 1000)
  surv <- estimator(time)
  
  plot.df <- data.frame(time = time, surv = surv)
  
  ggplot(plot.df, aes(x = time, y = surv)) +
    geom_line(color = "tomato", linewidth = 1) +
    scale_y_continuous(limits = c(0, 1)) +
    labs(title = "Estymator Rossa-Zieliński",
         x = "Czas do zdarzenia (t)",
         y = "Funkcja przeżycia S(t)") +
    theme_minimal()
}
```

Porównamy graficznie estmator Kaplana-Maiera z jego ulepszoną wersją estymatorem Rossy-Zielińskiego.

W tym celu sporządzono wykresy dla danych klinicznych pacjentów przedstawionych w artykule Rossy-Zielińskiego, a także dla danych z zadania 3 z listy 2 oraz z zadania 2 z listy 7.

```{r echo = FALSE}
times <- c(6, 6, 6, 6, 7, 9, 10, 10, 11, 13, 16, 17, 19, 20, 22, 23, 25, 32, 32, 34, 35)
deltas <- c(1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0)

df.rz <- data.frame(times <- times, deltas <- deltas)

rz_km_plot <- function(df, m1 = 2, m2 = 5, to = 3) {
  
  time_rz1 <- seq(0, to, length.out = 1000)
  surv_rz1 <- rossa.zielinski.estimator(df, m1)(time_rz1)
  df_rz1 <- data.frame(time = time_rz1, surv = surv_rz1, group = "RZ", panel = "M2")
  
  time_rz2 <- seq(0, to, length.out = 1000)
  surv_rz2 <- rossa.zielinski.estimator(df, m2)(time_rz2)
  df_rz2 <- data.frame(time = time_rz2, surv = surv_rz2, group = "RZ", panel = "M5")
  
  fit <- survfit(Surv(df$times, df$deltas) ~ 1)
  idx <- which(fit$n.event > 0)
  df_km1 <- data.frame(time = c(0, fit$time[idx]), surv = c(1, fit$surv[idx]), group = "KM", panel = "M2")
  df_km2 <- data.frame(time = c(0, fit$time[idx]), surv = c(1, fit$surv[idx]), group = "KM", panel = "M5")
  
  plot_df <- rbind(df_rz1, df_rz2, df_km1, df_km2)
  plot_df$panel <- factor(plot_df$panel, levels = c("M2", "M5"))
  
  ggplot(plot_df, aes(x = time, y = surv, color = group)) +
    geom_step(data = subset(plot_df, group == "KM"), linewidth = 0.8) +
    geom_line(data = subset(plot_df, group == "RZ"), linewidth = 0.8) +
    facet_wrap(~panel, ncol = 2, scales = "free_x",
               labeller = as_labeller(c("M2" = "m==2", "M5" = "m==5"), label_parsed)) +
    scale_color_manual(values = c("KM" = "tomato", "RZ" = "steelblue"),
                       labels = c("KM" = "Kaplana-Meiera", "RZ" = "Rossy-Zielińskiego")) +
    scale_y_continuous(limits = c(0, 1)) +
    labs(x = "Czas", y = expression(hat(S)(t)), color = "Estymator") +
    theme_minimal() +
    theme(
      legend.position = "bottom",
      axis.title.y.right = element_blank(),
      axis.text.y.right = element_blank(),
      axis.ticks.y.right = element_blank()
    )
}
```

```{r rossa-zielinski1, echo = FALSE, fig.cap="Porównanie wstymatora Kaplana-Meiera oraz Rossy-Zielińskiego dla zbioru danych klinicznych pacjentów", warning=FALSE}
rz_km_plot(df.rz, to = 40)
```

Z \hyperref[fig:rossa-zielinski1]{Wykresu \ref*{fig:rossa-zielinski1}.} można odczytać, że generowane wykresy są bardzo podobne do tych przedstawionych w artykule. Można przypuszczać, że opracowany algorytm działa poprawnie.

```{r rossa-zielinski2, echo = FALSE, fig.cap="Porównanie wstymatora Kaplana-Meiera oraz Rossy-Zielińskiego dla zbioru danych dotyczących leków - lek A", warning=FALSE}
rz_km_plot(df.A, to = 1.2)
```

\hyperref[fig:rossa-zielinski2]{Wykres \ref*{fig:rossa-zielinski2}.} pokazuje, w jaki sposób estymator wygładza klasyczny estymator Kaplana–Meiera dla danych dotyczących leków - lek A.

```{r rossa-zielinski3, echo = FALSE, fig.cap="Porównanie wstymatora Kaplana-Meiera oraz Rossy-Zielińskiego dla zbioru danych dotyczących leków - lek B", warning=FALSE}
rz_km_plot(df.B, to = 1.2)
```

\hyperref[fig:rossa-zielinski3]{Wykres \ref*{fig:rossa-zielinski3}.} pokazuje, w jaki sposób estymator wygładza klasyczny estymator Kaplana–Meiera dla danych dotyczących leków - lek B.

```{r rossa-zielinski4, echo = FALSE, fig.cap="Porównanie wstymatora Kaplana-Meiera oraz Rossy-Zielińskiego dla zbioru danych dotyczących pacjentów z rakiem jajnka - typ II", warning=FALSE}
rz_km_plot(df.II, to = 1500)
```

\hyperref[fig:rossa-zielinski4]{Wykres \ref*{fig:rossa-zielinski4}.} pokazuje, w jaki sposób estymator wygładza klasyczny estymator Kaplana–Meiera dla danych dotyczących pacjentów z rakiem jajnika typu II.

```{r rossa-zielinski5, echo = FALSE, fig.cap="Porównanie wstymatora Kaplana-Meiera oraz Rossy-Zielińskiego dla zbioru danych dotyczących pacjentów z rakiem jajnka - typ IIIA", warning=FALSE}
rz_km_plot(df.III, to = 1500)
```

\hyperref[fig:rossa-zielinski5]{Wykres \ref*{fig:rossa-zielinski5}.} pokazuje, w jaki sposób estymator wygładza klasyczny estymator Kaplana–Meiera dla danych dotyczących pacjentów z rakiem jajnika typu IIIA. Tym razem czasy są znacznie krótsze, a estymator dla wartości powyżej ostatniej obserwacji "odbija" w prawo. Można zauważyć, że dla $m = 5$ estymator "odbija” nieco wcześniej.

Podsumowując, estymator Rossy-Zielińskiego sprawnie wygładza funkcję przeżycia estymowaną przez Kaplana–Meiera, dobrze dopasowując ją w okolicach czasów zdarzeń, jednocześnie eliminując nagłe skoki i fluktuacje wynikające z małych prób. Dzięki temu estymator daje bardziej stabilny i ciągły obraz ryzyka przeżycia, ułatwiając interpretację oraz porównania między grupami pacjentów.

\newpage

# Bibliografia

\begin{thebibliography}{2}

\bibitem{gupta1999}
R. D. Gupta i D. Kundu,
\textit{Generalized Exponential Distributions},
Australian \& New Zealand Journal of Statistics, 41(2):173--188, 1999,
\href{https://home.iitk.ac.in/~kundu/paper47.pdf}{PDF}.

\bibitem{rossa2002}
Agnieszka Rossa i Ryszard Zieliński,
\textit{A Simple Improvement of the Kaplan-Meier Estimator},
Communications in Statistics - Theory and Methods, 31(1):147-158, 2002,
\href{https://doi.org/10.1081/STA-120002440}{DOI: 10.1081/STA-120002440}.

\end{thebibliography}